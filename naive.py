# -*- coding: utf-8 -*-
"""Naive.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tjm6-tAi6R5Uzl1eY6Dgb8BzmIPm6L3b

# Naive bayes

# Read and check for missing values
"""

#from wwo_hist import retrieve_hist_data
# import os
# os.chdir(".")
# frequency = 24
# start_date = '01-JUN-2019'
# end_date = '01-DEC-2019'
# api_key = 'f824dca4802c45fb89e110937212102'
# location_list = ['Austin']
# hist_weather_data = retrieve_hist_data(api_key,
#                                 location_list,
#                                 start_date,
#                                 end_date,
#                                 frequency,
#                                 location_label = False,
#                                 export_csv = True,
#                                 store_df = True)

import pandas as pd
data = pd.read_csv("austin_weather.csv")
#checking for missing values
data.info()
data.head()

"""# Preprocessing"""

display(data)
data = data.replace('T', 1.0)
data = data.replace('-', '0')
data = data.drop(
    ['Events', 'Date', 'SeaLevelPressureHighInches', 'SeaLevelPressureLowInches','VisibilityHighMiles','VisibilityLowMiles','TempHighF','TempLowF','DewPointHighF','DewPointLowF','WindHighMPH','WindAvgMPH','HumidityHighPercent','HumidityLowPercent'], axis=1)
for i in data.columns:
  data[i]=pd.to_numeric(data[i])
data.info()

data['PrecipitationSumInches']=[0 if x==0 else 1 for x in data['PrecipitationSumInches']]
data.head(200)

"""# Splitting data"""

from sklearn.model_selection import train_test_split
train, test = train_test_split(data, test_size=0.2)
train

"""# Likelihood table"""

ty = train[train['PrecipitationSumInches']==1].copy()
ty=ty.drop(['PrecipitationSumInches'],axis=1)
yes_probab=len(ty)/len(train)
yes_probab

tn = train[train['PrecipitationSumInches']==0].copy()
tn=tn.drop(['PrecipitationSumInches'],axis=1)
tn.head()
no_probab=len(tn)/len(train)
no_probab

print("Probability of yes: ")
print(yes_probab)
print("Probability of no: ")
print(no_probab)

import statistics
v1=[]
for t in ty.columns:  
    rowx=[]
    rowx.append(t)  
    rowx.append(statistics.mean(ty[t]))
    rowx.append(statistics.variance(ty[t]))
    rowx.append(statistics.mean(ty[t]))
    rowx.append(statistics.variance(tn[t]))
    v1.append(rowx)
df = pd.DataFrame(v1, columns = ['column','Mean_Yes','Variance_Yes','Mean_No','Variance_No']) 
df=df.set_index('column').T
display(df)

import math
test
nr1 = len(test)
nc1 = len(test.columns)

t_data=[]

for j in range(nr1):
  tr = test.iloc[j]
  yess = 1
  noo = 1
  td = 0
  for i in test.columns:
    if i!="PrecipitationSumInches":
      list1=df[i].tolist()
      yes_mean=list1[0]
      yes_var=list1[1]
      no_mean=list1[2]
      no_var=list1[3]
      noo=noo*((1/(math.sqrt(2*math.pi)*no_var)) * math.exp(-(((tr[i]-no_mean)**2)/(2*(no_var**2)))))
      yess=yess* ((1/(math.sqrt(2*math.pi)*yes_var)) * math.exp(-(((tr[i]-yes_mean)**2)/(2*(yes_var**2)))))
  yess=yess*yes_probab
  noo=noo*no_probab
  if yess>noo:
    td = 1
  t_data.append(td)

"""# Analysis"""

test['Outcome']=t_data
analysis = [len(test[(test['PrecipitationSumInches']== 1) & (test['Outcome']==1)]), len(test[(test['PrecipitationSumInches']== 0) 
& (test['Outcome']==0)]), len(test[(test['PrecipitationSumInches']== 1) & (test['Outcome']==0)]), len(test[(test['PrecipitationSumInches']== 0) & (test['Outcome']==1)])]
print("True positive: ")
print(analysis[0])
print("True negative: ")
print(analysis[1])
print("False positive: ")
print(analysis[2])
print("False negative: ")
print(analysis[3])
print("Accuracy: ")
acc1=(analysis[0]+analysis[1])/(analysis[0]+analysis[1]+analysis[2]+analysis[3])*100
print(acc1)



"""#Bayesian belief"""

import pandas as pd

from sklearn.model_selection import train_test_split

df = pd.read_csv("austin_weather.csv")
print(df)

df = df.replace('T', 1.0)
df = df.replace('-', '0')
df = df.drop(
    ['Events', 'Date', 'SeaLevelPressureHighInches', 'SeaLevelPressureLowInches','VisibilityHighMiles','VisibilityLowMiles', 'VisibilityAvgMiles','TempHighF','TempLowF','DewPointHighF','DewPointLowF','WindHighMPH','WindAvgMPH','HumidityHighPercent','HumidityLowPercent'], axis=1)
df['PrecipitationSumInches']=[0 if x=='0' else 1 for x in df['PrecipitationSumInches']]

df['DewPointAvgF'] = df['DewPointAvgF'].astype(int)
df['HumidityAvgPercent'] = df['HumidityAvgPercent'].astype(float)
df['SeaLevelPressureAvgInches'] = df['SeaLevelPressureAvgInches'].astype(float)
df['WindGustMPH'] = df['WindGustMPH'].astype(float)

df.rename(columns = {'PrecipitationSumInches':'Rainfall'}, inplace = True) 

print(df)

data = df

#Converting to categorized data

"""# Conversion into categorical data"""

#for TempAvg
min_val = data['TempAvgF'].min()
max_val = data['TempAvgF'].max()
bins = [0, 50 , 75 , 100]
labels = ['low', 'moderate', 'high' ]
data['TempCat'] = pd.cut(data['TempAvgF'], bins=bins, labels=labels, include_lowest=True)

#for DewPointAvgF
min_val = data['DewPointAvgF'].min()
max_val = data['DewPointAvgF'].max()
bins = [0 , 30, 55, 80]
labels = ['low', 'moderate', 'high']
data['DewPointCat'] = pd.cut(data['DewPointAvgF'], bins=bins, labels=labels, include_lowest=True)

#for HumidityAvgPercent
min_val = data['HumidityAvgPercent'].min()
max_val = data['HumidityAvgPercent'].max()
bins = [0, 50 , 75 , 100]
labels = ['low', 'moderate', 'high']
data['HumidityCat'] = pd.cut(data['HumidityAvgPercent'], bins=bins, labels=labels, include_lowest=True)

#for SeaLevelPressureAvgInches
min_val = data['SeaLevelPressureAvgInches'].min()
max_val = data['SeaLevelPressureAvgInches'].max()
bins = [0 , 30.135 , 50]
labels = ['low' , 'high']
data['PressureCat'] = pd.cut(data['SeaLevelPressureAvgInches'], bins=bins, labels=labels, include_lowest=True)

#for WindGustMPH
min_val = data['WindGustMPH'].min()
max_val = data['WindGustMPH'].max()
bins = [0, 32 , 60]
labels = ['low' , 'high']
data['WindCat'] = pd.cut(data['WindGustMPH'], bins=bins, labels=labels, include_lowest=True)
data = data.drop(['TempAvgF' , 'DewPointAvgF' , 'HumidityAvgPercent' ,
                    'SeaLevelPressureAvgInches' , 'WindGustMPH'], axis=1)
#Conversion to categorical data complete

"""# Splitting data"""

data = data[['TempCat', 'DewPointCat', 'HumidityCat', 'PressureCat', 'WindCat' , 'Rainfall']]
print(data)
train, test = train_test_split(data, test_size=0.2)

"""# Creating network"""

#Constructing Network
NetTree = {'TempCat': ['PressureCat'], 'DewPointCat': ['PressureCat'], 
           'HumidityCat': ['DewPointCat'], 'PressureCat': [], 
           'WindCat': ['PressureCat'], 
           'Rainfall': ['TempCat', 'HumidityCat','WindCat' ]}
  
print(NetTree)

att_list = ['PressureCat' , 'WindCat' , 'DewPointCat' ,'TempCat'  , 'HumidityCat' , 'Rainfall']

CPT = {}

#For nodes with no parent
for i in att_list: 
  temp = {}
  if len(NetTree[i]) == 0: 
    x = train[i].value_counts().sort_index() 
    for j in range(len(x.index)): 
      temp[x.index[j]] = len(train[train[i] == x.index[j]])/len(train) 
      
    CPT[i]=temp

# For attributes with 1 parent node
for i in att_list:
  
  if len(NetTree[i]) == 1:
    x = train[NetTree[i][0]].value_counts().sort_index()
    y = train[i].value_counts().sort_index()
    temp2 = {}
    for j in range(len(x.index)):
      temp1 = {}
      for k in range(len(y.index)):
        temp1[y.index[k]] = len(train[(train[NetTree[i][0]] == x.index[j]) & (train[i] == y.index[k])])/len(train[train[NetTree[i][0]] == x.index[j]])
      temp2[x.index[j]] = temp1
    CPT[i] = temp2

# For attributes with 2 parent nodes
for i in att_list:
  if len(NetTree[i]) == 2:
    x = train[NetTree[i][0]].value_counts().sort_index()
    y = train[NetTree[i][1]].value_counts().sort_index()
    z = train[i].value_counts().sort_index()

    temp = {}
    for j in range(len(x.index)):
      for k in range(len(y.index)):
        temp1 = {}
        for l in range(len(z.index)):
          num = len(train[(train[NetTree[i][0]] == x.index[j]) & (train[NetTree[i][1]] == y.index[k]) & (train[i] == z.index[l])])
          den = len(train[(train[NetTree[i][0]] == x.index[j]) & (train[NetTree[i][1]] == y.index[k])])
          temp1[z.index[l]] = num/den
        temp[(x.index[j], y.index[k])] = temp1
    
    CPT[i] = temp

# For attributes with 3 parent nodes
for i in att_list:
  if len(NetTree[i]) == 3:
    x = train[NetTree[i][0]].value_counts().sort_index()
    y = train[NetTree[i][1]].value_counts().sort_index()
    z = train[NetTree[i][2]].value_counts().sort_index()
    a = train[i].value_counts().sort_index()
    

    temp = {}
    for j in range(len(x.index)):
      for k in range(len(y.index)):
        for l in range(len(z.index)):
          temp1 = {}
          for m in range(len(a.index)):
            print
            num = len(train[(train[NetTree[i][0]] == x.index[j]) & (train[NetTree[i][1]] == y.index[k]) & (train[NetTree[i][2]] == z.index[l]) & (train[i] == a.index[m])])
            den = len(train[(train[NetTree[i][0]] == x.index[j]) & (train[NetTree[i][1]] == y.index[k]) & (train[NetTree[i][2]] == z.index[l])])
            if den != 0:
              temp1[a.index[m]] = num/den
            else:
              temp1[a.index[m]] = 0
          temp[(x.index[j], y.index[k], z.index[l])] = temp1
    
    CPT[i] = temp

print(CPT)

#Testing
testData = test                #copying into another variable to check later
testData = testData.drop(['Rainfall'] , axis = 1)           #dropping output attribute
n = len(testData)
testRainfall = []

for l in range(n):
  tr = testData.iloc[l]
  tp = 1                    # initializing total probability
  td = 0                    # initializing output (Rainfall)
  for i in testData.columns: 
    if len(NetTree[i]) > 0:         # if parent node exists
      temp = []
      for j in range(len(NetTree[i])): # iterating through parents of each attribute
        temp.append(tr[NetTree[i][j]])
      if len(NetTree[i]) != 1:       # if more than 1 parent node
        if CPT[i][tuple(temp)][tr[i]] != 0: 
          tp = tp * CPT[i][tuple(temp)][tr[i]] 
      else: #only 1 parent
        if CPT[i][tr[NetTree[i][j]]][tr[i]] != 0: 
          tp = tp * CPT[i][tr[NetTree[i][j]]][tr[i]] 
    else:
      #attributes with no parents
      if CPT[i][tr[i]] != 0:
        tp = tp * CPT[i][tr[i]] 

  temp = []
  # for getting the tupple for output attribute
  for i in range(len(NetTree['Rainfall'])):
    temp.append(tr[NetTree['Rainfall'][i]])

  t1 = tp * CPT['Rainfall'][tuple(temp)][1]    # calculating yes probabilty
  t0 = tp * CPT['Rainfall'][tuple(temp)][0]    # calculating no probability
  if (t1>t0):     
    td=1 
  testRainfall.append(td) 
test = test.assign(testRes = testRainfall ) # adding a test result column in the test dataframe for comparison with test output and original output

"""# Accuracy"""

#Checking Accuracy
match=0
notmatch=0
for i in range(n):
    tr = test.iloc[i] 
    if (tr['Rainfall'])==(tr['testRes']):
        match+=1
    else:
        notmatch+=1
print('Correct predictions: ' + str(match))
print('Incorrect Predictions: ' + str(notmatch))
acc = match/(match+notmatch)*100
print('Accuracy = ' + str(acc))

"""# Comparison"""

import matplotlib.pyplot as plt
fig = plt.figure()
ax = fig.add_axes([0,0,1,1])
algo = ['NB', 'BBN']
accuracy = [acc1,acc]
ax.bar(algo,accuracy)
plt.show()